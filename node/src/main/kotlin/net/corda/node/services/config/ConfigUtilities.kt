package net.corda.node.services.config

import com.typesafe.config.Config
import com.typesafe.config.ConfigFactory
import com.typesafe.config.ConfigParseOptions
import com.typesafe.config.ConfigRenderOptions
import net.corda.core.crypto.Crypto
import net.corda.core.identity.CordaX500Name
import net.corda.core.internal.*
import net.corda.nodeapi.internal.config.SSLConfiguration
import net.corda.nodeapi.internal.crypto.*
import org.bouncycastle.asn1.x509.GeneralName
import org.bouncycastle.asn1.x509.GeneralSubtree
import org.bouncycastle.asn1.x509.NameConstraints
import org.slf4j.LoggerFactory
import java.nio.file.Path
import java.security.cert.X509Certificate

fun configOf(vararg pairs: Pair<String, Any?>): Config = ConfigFactory.parseMap(mapOf(*pairs))
operator fun Config.plus(overrides: Map<String, Any?>): Config = ConfigFactory.parseMap(overrides).withFallback(this)

object ConfigHelper {
    private val log = LoggerFactory.getLogger(javaClass)
    fun loadConfig(baseDirectory: Path,
                   configFile: Path = baseDirectory / "node.conf",
                   allowMissingConfig: Boolean = false,
                   configOverrides: Config = ConfigFactory.empty()): Config {
        val parseOptions = ConfigParseOptions.defaults()
        val defaultConfig = ConfigFactory.parseResources("reference.conf", parseOptions.setAllowMissing(false))
        val appConfig = ConfigFactory.parseFile(configFile.toFile(), parseOptions.setAllowMissing(allowMissingConfig))
        val finalConfig = configOf(
                // Add substitution values here
                "baseDirectory" to baseDirectory.toString())
                .withFallback(configOverrides)
                .withFallback(appConfig)
                .withFallback(defaultConfig)
                .resolve()
        log.info("Config:\n${finalConfig.root().render(ConfigRenderOptions.defaults())}")
        return finalConfig
    }
}

/**
 * Strictly for dev only automatically construct a server certificate/private key signed from
 * the CA certs in Node resources. Then provision KeyStores into certificates folder under node path.
 */
fun NodeConfiguration.configureWithDevSSLCertificate() = configureDevKeyAndTrustStores(myLegalName)

fun SSLConfiguration.configureDevKeyAndTrustStores(myLegalName: CordaX500Name) {
    certificatesDirectory.createDirectories()
    if (!trustStoreFile.exists()) {
        X509Utilities.loadDevTrustStore().internal.save(trustStoreFile, trustStorePassword)
    }
    if (!sslKeystore.exists() || !nodeKeystore.exists()) {
        val (nodeKeyStore) = createKeyStores(X509Utilities.DEV_ROOT_CA.certificate, X509Utilities.DEV_INTERMEDIATE_CA, myLegalName, "cordacadevkeypass")

        // Move distributed service composite key (generated by IdentityGenerator.generateToDisk) to keystore if exists.
        val distributedServiceKeystore = certificatesDirectory / "distributedService.jks"
        if (distributedServiceKeystore.exists()) {
            val serviceKeystore = X509KeyStore.fromFile(distributedServiceKeystore, "cordacadevpass")
            nodeKeyStore.update {
                serviceKeystore.aliases().forEach {
                    if (serviceKeystore.internal.isKeyEntry(it)) {
                        setPrivateKey(it, serviceKeystore.getPrivateKey(it, "cordacadevkeypass"), serviceKeystore.getCertificateChain(it))
                    } else {
                        setCertificate(it, serviceKeystore.getCertificate(it))
                    }
                }
            }
        }
    }
}

/**
 * An all in wrapper to manufacture a server certificate and keys all stored in a KeyStore suitable for running TLS on the local machine.
 * @param keyPassword PrivateKey access password for the generated keys.
 * It is recommended that this is the same as the storePassword as most TLS libraries assume they are the same.
 * @return A pair of [X509KeyStore] objects, the first being the node key store, and the second being the SSL key store
 * containing a private key, certificate chain and root CA public cert for use in TLS applications.
 */
fun SSLConfiguration.createKeyStores(rootCaCert: X509Certificate,
                                     intermediateCa: CertAndKeyPair,
                                     legalName: CordaX500Name,
                                     keyPassword: String = keyStorePassword): Pair<X509KeyStore, X509KeyStore> {
    val nodeCaKeyPair = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME)
    val nameConstraints = NameConstraints(arrayOf(GeneralSubtree(GeneralName(GeneralName.directoryName, legalName.x500Name))), arrayOf())
    val nodeCaCert = X509Utilities.createCertificate(
            CertificateType.NODE_CA,
            intermediateCa.certificate.toX509CertHolder(),
            intermediateCa.keyPair,
            legalName,
            nodeCaKeyPair.public,
            nameConstraints = nameConstraints
    )

    val nodeKeyStore = openNodeKeyStore(createNew = true)
    nodeKeyStore.update {
        setPrivateKey(
                X509Utilities.CORDA_CLIENT_CA,
                nodeCaKeyPair.private,
                listOf(nodeCaCert.cert, intermediateCa.certificate, rootCaCert),
                keyPassword = keyPassword
        )
    }

    val sslKeyStore = openSslKeyStore(createNew = true)
    sslKeyStore.update {
        val tlsKeyPair = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME)
        val clientTLSCert = X509Utilities.createCertificate(CertificateType.TLS, nodeCaCert, nodeCaKeyPair, legalName, tlsKeyPair.public)
        setPrivateKey(
                X509Utilities.CORDA_CLIENT_TLS,
                tlsKeyPair.private,
                listOf(clientTLSCert.cert, nodeCaCert.cert, intermediateCa.certificate, rootCaCert),
                keyPassword = keyPassword
        )
    }

    return Pair(nodeKeyStore, sslKeyStore)
}
